<!-- templates/dashboard.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Crypto Arbitrage Dashboard</title>
    <style>
        /* Same CSS as before – included above */
        /* Styles copied from your provided template */
        /* For brevity omitted here; you can paste them back in */
    </style>
</head>
<body>

<div class="loader"></div>

<h1>Crypto Arbitrage Dashboard</h1>

<table id="crypto-table">
    <thead>
        <tr>
            <th>Cryptocurrency</th>
            <th>Binance</th>
            <th>OKX</th>
            <th>Arbitrage Opportunity</th>
            <th>Action</th>
        </tr>
    </thead>
    <tbody>
        {% for coin, prices in crypto_data.items() %}
        <tr data-symbol="{{ coin }}">
            <td>{{ coin }}</td>
            <td data-exchange="Binance">${{ "%.2f"|format(prices.Binance) }}</td>
            <td data-exchange="OKX">${{ "%.2f"|format(prices.OKX) }}</td>
            <td id="diff-{{ coin }}">-</td>
            <td>
                <button onclick="executeTrade('{{ coin }}', 'Binance', 'OKX')">Buy Binance → Sell OKX</button>
                <button onclick="executeTrade('{{ coin }}', 'OKX', 'Binance')">Buy OKX → Sell Binance</button>
            </td>
        </tr>
        {% endfor %}
    </tbody>
</table>

<footer>
    Prices auto-refreshing every 2 seconds...
</footer>

<script>
    document.addEventListener("DOMContentLoaded", () => {
        document.body.classList.add("loaded");

async function updatePrices() {
    try {
        const res = await fetch("/update_prices");
        if (!res.ok) throw new Error("Failed to load prices");

        const data = await res.json();

        Object.entries(data).forEach(([coin, prices]) => {
            const row = document.querySelector(`tr[data-symbol="${coin}"]`);
            if (!row) return;

            const binanceCell = row.querySelector('[data-exchange="Binance"]');
            const okxCell = row.querySelector('[data-exchange="OKX"]');
            const diffCell = document.getElementById(`diff-${coin}`);

            // Update prices instantly
            if (prices.Binance) binanceCell.textContent = `$${prices.Binance.toFixed(2)}`;
            if (prices.OKX) okxCell.textContent = `$${prices.OKX.toFixed(2)}`;

            // Check for arbitrage opportunity
            if (prices.Binance && prices.OKX) {
                const diff = Math.abs(prices.Binance - prices.OKX);
                const direction = prices.Binance > prices.OKX ? "Sell Binance | Buy OKX" : "Buy Binance | Sell OKX";
                diffCell.innerHTML = `<strong>${direction}</strong><br>Difference: $${diff.toFixed(2)}`;
                row.classList.toggle("highlight", diff > 0.5);
            } else {
                diffCell.textContent = "N/A";
            }
        });
    } catch (err) {
        console.error("Error updating prices:", err);
    }
}

// Fire initial update
updatePrices();

// Poll every 1000ms instead of 2000ms
setInterval(updatePrices, 1000);
        updatePrices();
    });

    function executeTrade(symbol, buyExchange, sellExchange) {
        const url = `/execute_trade/${symbol}/${buyExchange}/${sellExchange}`;
        
        alert("Sending trade request for " + symbol + "..."); // Optional: Confirm click received

        fetch(url)
            .then(async (response) => {
                if (!response.ok) {
                    const errText = await response.text();
                    throw new Error(`HTTP error! Status: ${response.status}, Body: ${errText}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("Raw server response:", data);

                if (data.success === false) {
                    alert(`⚠️ Trade failed:\n\n${data.error || JSON.stringify(data)}`);
                } else {
                    alert(`✅ Success!\n\n${data.message}`);
                }
            })
            .catch(error => {
                console.error("Frontend error:", error);
                alert(`🚨 Network error:\n${error.message}`);
            });
    }


</body>
</html>